# ビルドシミュレーター

エルデンリング ナイトレインのビルド最適化シミュレーター

## 概要

ユーザーが所持する遺物から、指定された条件を満たす最適なビルド（遺物の組み合わせ）を計算するシステムです。
整数線形計画法（ILP）を用いて、複数の制約条件を同時に満たすビルドを効率的に探索します。

## アーキテクチャ

### ファイル構成

- **simulator.ts** - メインシミュレーターロジック
- **worker.ts** - Web Worker 実装（重い計算をメインスレッド外で実行）
- **constraints.ts** - yalps による制約条件定義
- **variables.ts** - 整数線形計画の変数定義
- **categoryFilter.ts** - カテゴリ制約によるビルドフィルタリング
- **createBuild.ts** - ビルドオブジェクトの生成
- **scoring.ts** - ビルドのスコアリング（優先順位付け）
- **types.ts** - 型定義

### 処理フロー

```
1. ユーザー入力（所持遺物、必要効果、除外効果など）
   ↓
2. 遺物効果グループの統合処理
   ↓
3. yalps による整数線形計画問題の構築
   ↓
4. 制約条件の追加
   ↓
5. 最適化ソルバーの実行
   ↓
6. カテゴリ制約によるフィルタリング（左側優先ルール）
   ↓
7. スコアリングによる優先順位付け
   ↓
8. 結果の返却
```

## 重要な仕様

### 左側優先ルール（Category Priority Rule）

エルデンリング ナイトレインでは、**同じカテゴリの効果を持つ遺物を複数装備できますが、効果として発動するのは左側のスロットの遺物のみ**という仕様があります。

#### 具体例

献器のスロット構成が `[黄, 緑, 緑]` で以下の遺物を持っている場合:

- 黄色遺物: 輝剣の円陣（戦技カテゴリ） + 最大HP上昇
- 緑遺物1: グラビタス（戦技カテゴリ）
- 緑遺物2: 最大HP上昇（中）

**ケース1: マッチしない例**

必要な効果: `グラビタス` + `最大HP上昇`

```
[黄色遺物, 緑遺物1, ×]
 ↑        ↑
 輝剣     グラビタス（無効化される）
```

最大HP上昇を得るには黄色遺物が必要ですが、左側の黄色遺物の「輝剣の円陣」が優先され、緑遺物の「グラビタス」は無効化されるため、条件を満たせません。

**ケース2: マッチする例**

必要な効果: `輝剣の円陣` + `最大HP上昇`

```
[黄色遺物, 緑遺物2, ×]
 ↑        ↑
 輝剣     最大HP上昇
```

左側の輝剣の円陣が有効になり、緑遺物から最大HP上昇も得られるため、条件を満たします。

#### 実装

左側優先ルールは `categoryFilter.ts` の `satisfiesCategoryConstraints()` 関数で実装されています:

1. ビルド内の各遺物の効果を左から右にスキャン
2. 各カテゴリで最初に見つかった効果のみを「有効」とマーク
3. 有効な効果が要求効果を満たしているかチェック
4. 満たしていないビルドは除外

### 遺物効果グループの統合

遺物効果は関連する効果ごとにグループ化されており、シミュレーション時に統合処理が行われます:

- **stacksWithSelf**: 同じ効果を複数装備可能
- **stacksAcrossLevels**: レベル違いの効果を重複可能
- **デメリット効果**: 適切に処理

詳細は `app/data/generated/relicEffectGroups.ts` を参照。

### 制約条件

`constraints.ts` では以下の制約を定義:

1. **スロット制約**: 各スロットに1つの遺物のみ配置
2. **色制約**: スロットの色と遺物の色が一致
3. **所持数制約**: 所持している遺物のみ使用
4. **必要効果制約**: 指定された効果を含む
5. **除外効果制約**: 指定された効果を含まない
6. **深層遺物除外制約**: オプションで深層遺物を除外
7. **カテゴリ制約**: 左側優先ルールによる効果の有効性（`categoryFilter.ts` で実装）

### スコアリング

`scoring.ts` では以下の基準でビルドを評価:

- 深層遺物より通常遺物を優先
- デメリット効果を持たないビルドを優先
- 追加効果が多いビルドを優先

## パフォーマンス

- **Web Worker**: 重い計算処理をメインスレッド外で実行
- **Comlink**: 型安全な Worker 通信
- **ベンチマーク**: `npm run bench` で測定可能

## テスト

すべての主要ロジックにはテストが含まれています:

- `simulator.spec.ts` - シミュレーター全体のテスト（左側優先ルールを含む）
- `categoryFilter.spec.ts` - カテゴリフィルタリングのテスト
- `constraints.spec.ts` - 制約条件のテスト
- `createBuild.spec.ts` - ビルド生成のテスト

```bash
npm run test              # テスト watch モード
npm run test:run          # テスト単発実行
npm run coverage:run      # カバレッジレポート生成
```

## 開発ガイド

### 新しい制約条件の追加

1. `constraints.ts` に制約を定義
2. `types.ts` に必要な型を追加
3. `simulator.ts` で制約を適用
4. テストを追加

### パフォーマンス改善

1. `simulator.bench.ts` でベンチマークを作成
2. `npm run bench` で現状を測定
3. 最適化を実施
4. 再度測定して改善を確認

## 関連ドキュメント

- プロジェクト全体の構造: `/CLAUDE.md`
- 遺物データ定義: `app/data/relics.ts`
- 遺物効果定義: `app/data/relicEffects.ts`
- 献器定義: `app/data/vessels.ts`
